import BaseHandler from "./base-handler.js";
import { log } from "../../utils/log-util.js";
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// =====================
// Node环境变量处理类
// =====================

export class NodeHandler extends BaseHandler {
  /**
   * 兼容不同打包/部署方式的配置目录：
   * - Magisk/Android: $DANMU_API_HOME/config
   * - Magisk(旧):     app/danmu_api/config (通常是指向持久目录的 symlink)
   * - Upstream Node:  app/config
   */
  _resolveConfigPaths() {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    const candidates = [];

    // 1) Magisk/Android persistent home
    if (typeof process !== "undefined" && process.env?.DANMU_API_HOME) {
      candidates.push(path.join(process.env.DANMU_API_HOME, "config"));
    }

    // 2) app/config (upstream node server.js expects this)
    candidates.push(path.join(__dirname, "..", "..", "..", "..", "config"));

    // 3) danmu_api/config (some builds or Magisk symlink)
    candidates.push(path.join(__dirname, "..", "..", "..", "config"));

    // Choose first dir that already has config files
    for (const dir of candidates) {
      try {
        const envPath = path.join(dir, ".env");
        const yamlPath = path.join(dir, "config.yaml");
        if (fs.existsSync(envPath) || fs.existsSync(yamlPath)) {
          return { dir, envPath, yamlPath };
        }
      } catch {}
    }

    // Fallback: use the first candidate (or cwd/config)
    const dir = candidates[0] || path.join(process.cwd(), "config");
    return { dir, envPath: path.join(dir, ".env"), yamlPath: path.join(dir, "config.yaml") };
  }

  _ensureFile(filePath, initialContent = "") {
    try {
      fs.mkdirSync(path.dirname(filePath), { recursive: true });
      if (!fs.existsSync(filePath)) {
        fs.writeFileSync(filePath, initialContent, "utf8");
      }
    } catch (e) {
      throw new Error(`Failed to prepare file ${filePath}: ${e?.message || e}`);
    }
  }

  /**
   * 在本地配置文件中设置环境变量
   */
  updateConfigValue(key, value) {
    const { envPath, yamlPath } = this._resolveConfigPaths();

    // Always persist to .env (create if missing)
    this._ensureFile(envPath, "# Generated by danmu_api\n");

    let updated = false;

    try {
      // -----------------
      // Update .env
      // -----------------
      {
        const envContent = fs.readFileSync(envPath, "utf8");
        const lines = envContent.split(/\r?\n/);
        let keyFound = false;

        for (let i = 0; i < lines.length; i++) {
          const trimmed = lines[i].trim();
          if (!trimmed || trimmed.startsWith("#")) continue;
          const match = trimmed.match(/^([^=]+)=/);
          if (match && match[1].trim() === key) {
            lines[i] = `${key}=${String(value)}`;
            keyFound = true;
            break;
          }
        }

        if (!keyFound) {
          if (lines.length && lines[lines.length - 1] !== "") lines.push("");
          lines.push(`${key}=${String(value)}`);
        }

        fs.writeFileSync(envPath, lines.join("\n"), "utf8");
        log("info", `[server] Updated ${key} in .env (${envPath})`);
        updated = true;
      }

      // -----------------
      // Update config.yaml (only if it exists)
      // -----------------
      if (fs.existsSync(yamlPath)) {
        const yamlContent = fs.readFileSync(yamlPath, "utf8");
        const lines = yamlContent.split(/\r?\n/);
        let keyFound = false;

        const formatYamlValue = (v) => {
          if (v === null || v === undefined) return "null";
          if (typeof v === "boolean") return v ? "true" : "false";
          const s = String(v);
          if (s !== "" && !isNaN(v)) return String(Number(v));
          // JSON string literal is valid YAML scalar (YAML 1.2 is a superset of JSON).
          // This also safely escapes quotes/backslashes/newlines.
          return JSON.stringify(s);
        };

        for (let i = 0; i < lines.length; i++) {
          const trimmed = lines[i].trim();
          if (!trimmed || trimmed.startsWith("#")) continue;
          const match = trimmed.match(/^([^:]+):/);
          if (match && match[1].trim() === key) {
            lines[i] = `${key}: ${formatYamlValue(value)}`;
            keyFound = true;
            break;
          }
        }

        if (!keyFound) {
          if (lines.length && lines[lines.length - 1] !== "") lines.push("");
          lines.push(`${key}: ${formatYamlValue(value)}`);
        }

        fs.writeFileSync(yamlPath, lines.join("\n"), "utf8");
        log("info", `[server] Updated ${key} in config.yaml (${yamlPath})`);
        updated = true;
      }

      return updated;
    } catch (error) {
      log("error", "[server] Error updating configuration:", error?.message || error);
      throw error;
    }
  }

  /**
   * 设置环境变量并重新初始化全局配置
   */
  async setEnv(key, value) {
    log("info", "[server] Setting environment variable:", key, "=", value);

    try {
      const updated = this.updateConfigValue(key, value);
      if (!updated) return false;
      this.updateLocalEnv(key, value);
      return true;
    } catch (error) {
      log("error", "[server] ✗ Failed to set environment variable:", error?.message || error);
      throw error;
    }
  }

  /**
   * 添加新的环境变量
   */
  async addEnv(key, value) {
    return await this.setEnv(key, value);
  }

  /**
   * 删除环境变量
   */
  async delEnv(key) {
    const { envPath, yamlPath } = this._resolveConfigPaths();
    let deleted = false;

    try {
      // .env
      if (fs.existsSync(envPath)) {
        const envContent = fs.readFileSync(envPath, "utf8");
        const lines = envContent.split(/\r?\n/);
        const filteredLines = lines.filter(line => {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith("#")) return true;
          const match = trimmed.match(/^([^=]+)=/);
          return !(match && match[1].trim() === key);
        });
        fs.writeFileSync(envPath, filteredLines.join("\n"), "utf8");
        log("info", `[server] Deleted ${key} from .env (${envPath})`);
        deleted = true;
      }

      // config.yaml
      if (fs.existsSync(yamlPath)) {
        const yamlContent = fs.readFileSync(yamlPath, "utf8");
        const lines = yamlContent.split(/\r?\n/);
        const filteredLines = lines.filter(line => {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith("#")) return true;
          const match = trimmed.match(/^([^:]+):/);
          return !(match && match[1].trim() === key);
        });
        fs.writeFileSync(yamlPath, filteredLines.join("\n"), "utf8");
        log("info", `[server] Deleted ${key} from config.yaml (${yamlPath})`);
        deleted = true;
      }

      if (deleted) {
        this.delLocalEnv(key);
        return true;
      }
      return false;
    } catch (error) {
      log("error", "[server] ✗ Failed to delete environment variable:", error?.message || error);
      throw error;
    }
  }
}
